{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This repository serves as the opinionated knowledge hub that contains component descriptions best practices and tools for  developing complex UI features using Compose</p>"},{"location":"#work-in-progress","title":"\ud83d\udea7 Work in Progress","text":"<p>These pages are still work in progress and might contain spelling errors, inconsistencies and unfinished pages. </p>"},{"location":"#overview","title":"Overview","text":"<p>Featured approach has following components</p> <ul> <li>State - The static state of our Screen</li> <li>Actions - Set of user interactions available on the screen</li> <li>Screen - Stateless representation of our feature UI, consumes state and emits Actions</li> <li>Coordinator - Provides the state and consumes Actions. Coordinates different state providers and action handlers to fulfill user journey</li> <li>Route - Main entry point to our Screen. Remember the coordinator and actions. Collects the state</li> </ul> <p></p>"},{"location":"#resources","title":"Resources","text":"<p>The list of resources associated with Compose UI Architecture</p>"},{"location":"#articles","title":"Articles","text":"<ul> <li>Jetpack Compose UI Architecture - Monstarlab Engeneering Blog Article that would be a great introduction into the core concepts and its usage.</li> </ul>"},{"location":"#tools","title":"Tools","text":"<p>Jetpack Compose UI Archicture Templates IDE Plugin</p> <p>Android studio plugin that facilitates creating new Jetpack Compose powered UI screens for android. </p> <ul> <li>Provides a set of templates that can be used to create a set components described here </li> <li>Provides a set of Live Templates that can to write Compose UI code faster</li> </ul>"},{"location":"actions/","title":"Actions","text":"<p>The <code>Actions</code> represen the User Interactions that are happening in our <code>Screen</code> and being handled by <code>Coordinator</code>. Not every interaction though should be considered an Action.</p> <p>Here are few rules that higlight the purpose of <code>Actions</code> and their role in our Architecture</p>"},{"location":"actions/#actions-are-triggered-by-user","title":"Actions are triggered By User","text":"<p>The <code>Actions</code> are user interactions and can't be triggered without their involvement. Lets take this screen as an example. Here we would like to notify our parent component that the screen has been opened</p> <p><pre><code>data class Actions(\nval onTutorialIsCompleted: () -&gt; Unit\n)\n@Composable\nfun Screen(actions: Actions) {\nLaunchedEffect(Unit) {\naction.onScreenOpened()\n}\n}\n</code></pre>  While user has probably triggered the change in Navigation, first time rendering of Compose Screen is not User Interaction. thus it should not be part of the <code>Actions</code>. Whatever we wanted to do when user opens the screen, we can do it in <code>Route</code> or <code>Screen</code>.</p> <p>The most only thing that is actually triggered by the User are UI components: <code>Button</code>, <code>TextField</code> etc.</p> <pre><code>data class LoginActions(\nval onLoginButtonClicked: () -&gt; Unit,\nval onEmailChange: (String) -&gt; Unit,\nval onPasswordChange: (String) -&gt; Unit\n)\n@Composable\nfun LoginScreen(val actions: LoginActions) {\nColumn {\nTextField(onValueChange = actions.onEmailChange)\nTextField(onValueChange = actions.onPasswordChange)\nButton(onClick = actions.onLoginButtonClicked)\n}\n}\n</code></pre>"},{"location":"actions/#actions-drive-the-change-in-application-state","title":"Actions drive the change in application state","text":"<p>This rule eliminates User Interactions that don't influence our Application State. The <code>Action</code> intention is to change our Application State, for example by changing the <code>State</code> of our <code>ViewModel</code>, navigate to another <code>Route</code>, things like that.</p> <p>This really depends on the requirements you have for your <code>Screen</code> and what do you consider a <code>State</code>. For instance, lets say we have a component inside our screen that has a drop-down element.</p> <pre><code>fun SomeComponent(isRevealed: Boolean) {\nColumn {\nRow {\nText(\"Click to reveal\")\nDropdownButton()\n}\n}\nif (isRevealed) {\nText(\"More info\")\n}\n}\n</code></pre> <p>Lets say the <code>isRevealed</code> flag is not part of the Screen state, but rather an internal state of our component. In this case there is no point to expose the onClick action of our Dropdown button since we can this small component handle its own state</p> <p>Some components are better left handling its own state as long as it the only state it manages and no-one esle has access to it, so that we stll has one source of truth.</p>"},{"location":"coordinator/","title":"Coordinator","text":"<p>The coordinator the is the main component in our architecture. Every statefull Composable component, such as <code>LazyRow</code> and <code>Scaffold</code> has a state that drives how the component works, similiary, you can think of a Coordinator as the state of your flow or feature.</p> <p>Following figure demonstrates the flow of the data and how each component interacts with each other. </p> <p>This a simplistic version of whats going on. Looking closely, when we say the action is handled by the <code>Coordinator</code> is that will delegate this action some other component. Similiraly, the <code>Coordinator</code> doesn't store any state but rather relies other components to provide it. Let's call them State Providers and Action Handlers</p>"},{"location":"coordinator/#state-providers-action-handlers","title":"State Providers &amp; Action Handlers","text":"<p>The State Provider is the source of truth of some component. We can have multiple of those. The <code>Coordinator</code> then acts as a mediator allowing us to combine the states or expose partial states. </p> <p>The most common example of the State Provide can be the android <code>ViewModel</code> that exposes the state of our business logic. However, we can also consider other composable components state as a state provider, for example: <code>PagerState</code></p> <pre><code>data class ViewModelState(\nval items: List&lt;Item&gt;\n)\ndata class ScreenState(\nval currentItem: Item?\n)\nclass ExampleCoordinator(\nval viewModel: ViewModel,\nval pagerState: PagerState\n) {\nval stateFlow = combine(\nviewModel.stateFlow,\npagerState.currentPagerFlow()\n) { uiState, currentPage } {\nScreenState(uiState.items[currentPage])\n}\n}\n</code></pre> <p>The Action Handlers is something that can mutate our State. Very often the Action Handler can also act as the State Provider. </p> <p>In summary, the main idea of the Coordinator is to \"coordinate\" different State Providers and Action Handlers to perform some user journey</p> <pre><code>// coordinator scope\nclass LocationCoordinator(\nval permissionState: PermissionState,\nval mapState: MapState\n)\nfun focusOnUserLocation() {\nif (permissionState.isGranted) {\nmapState.focusOnCurrentLocation()\n} else {\npermissionState.launchPermissionRequest()\n}\n}\n</code></pre> <p>Following diagram demonstrates this in a more generic way</p> <p></p>"},{"location":"coordinator/#react-to-state-changes-side-effects","title":"React to State Changes - Side effects","text":"<p>Because of the Reactive nature of Compose handling something that we consider one shot events can be bit tricky. </p> <p>When inside <code>@Composable</code> we have access to different effects so we can do something only when certain conditions are met without worrying about re-compositions. </p> <p>But since we have <code>Coordinator</code> we can let it do that for us as well. Because the <code>Coordinator</code> is outside of Composable scope and doesn't get re-created due to the recompositions we can easily subscribe to the state changes and react to them in more straight forward fasion, just like we would normally do in our <code>ViewModel</code></p> <pre><code>class Coordinator(\nval viewModel: ViewModel,\nval context: Context,\nval scope: CoroutineScope\n) {\ninit {\nviewModel.errorFlow()\n.onEach { msg -&gt; context.showToast(msg) viewModel.dismissError()\n}\n.launchIn(scope)\n}\n}\n</code></pre> <p>Again this is basically the same thing we would with the Action coming in from the <code>Screen</code>, except now the source of this interaction is the State Provider it self and it doesn't leave the <code>Coordinator</code> and goes directly to the Action Handlers</p> <p></p>"},{"location":"screen/","title":"Screen","text":"<p>The <code>Screen</code> is the visual representation of the feature that we are working on. It is  component that renders our UI based on the given <code>State</code> and emits <code>Actions</code> for our <code>Coordinator</code> to handle. Here are a few rules we would like our <code>Screen</code> to flow.</p> <ul> <li>Easily Previewable - We should be able easily preview our screen with different states, across different device sizes and modes, light or dark</li> <li>Consise - The <code>Screen</code> component should be relatevely short, easy to read and understand. Encapsulating parts of it UI into separate components is a must. Also be aware of the number of nested blocks, having it small as possible makes the code much more readable</li> <li>State less. The <code>Screen</code> should consume state but not manage this state. It doesn't allowed to reference any other component is not UI only. </li> </ul>"},{"location":"screen/#state-consumption","title":"State consumption","text":"<p>The UI of the Screen is Rendered based on the Provided state, it can a ViewModel state or it can be a composable component state. It is good practice to let you component know a little as possible. Since the <code>Screen</code> is split into UI components we can make these components rely only the part of the state that is provided to the <code>Screen</code>. So the deeper we go through the UI tree the less components know about our specific feature and its state</p> <p>This makes these components more re-usable, agnostic to a specific ViewModel state, and causes less re-rendering wen recomposition</p> <pre><code>data class ExampleState(\nval user: User,\nval products: List&lt;Products&gt;\n)\ndata class ExampleActions(\nval onUserClicked: () -&gt; Unit,\nval onProductClick: (Product) -&gt; Unit\n)\n@Composable\nfun ExampleScreen(\nstate: ExampleState,\nactions: ExampleActions\n) {\nLazyColumn {\nitem {\nUserItem(state.user, actions.onUserClicked)\n}\nitems(state.products) { product -&gt; ProductItem(product, actions.onProductClicked)\n}\n}\n}\n@Composable\nfun UserItem(user: User, onClick: () -&gt; Unit) { /* */ }\n@Composable\nfun ProductItem(user: Product, onClick: (Product) -&gt; Unit) { /* */ }\n</code></pre>"},{"location":"screen/#effects","title":"Effects","text":"<p>The Compose Side Effects can also be a part of screen or a specific component. However, it is important to be aware the goal of that effects, what they are trying to achieve.</p> <p>Lets look a at following screen. We have Pager State and just received a new requirement to track every time user changes the page.</p> <pre><code>data class ScreenActions(val onPageChange: (Int) -&gt; Unit)\n@Composable\nfun Screen(\nval pagerState: PagerState\nactions: ScreenActions\n) {\nLaunchedEffect(pagerState) {\nsnapshotFlow { pagerState.currentPage }\n.onEach(actions::onPageChange)\n.launchIn(this)\n}\nItemsPager(state = pagerState)\n}\nclass Coordinator {\nfun handlePageChange(page: Int) {\n// our logic\n}\n}\n</code></pre> <p>So lets break down what we have here, once user has changed the page in the <code>Pager</code> 1. Our flow in <code>LaunchedEffect</code> detects the change and gets triggered 2. New page number is then being passed with <code>Actions</code> 3. The <code>Action</code> then is handled by our <code>Route</code> or <code>Coordinator</code></p> <p>So while this actually doing what we wanted it to do, the amount interactions and component tied to this actions is a bit redundat. Since the <code>PagerState</code> is external: we don't control the state, we only get notified about the changes. And it actually does nothing to the <code>Screen</code> we are dealing with. All that raises the question, why would we have this effect as part of the <code>Screen</code></p> <p>To fix this we can just move this effect into the <code>Coordinator</code>. This makes both <code>Screen</code> and <code>Actions</code> more consise and removes redundant Logic form them.</p> <pre><code>class Coordinator(val pagerState: PagerState, scope: CoroutineScope) {\ninit {\nsnapshotFlow { pagerState.currentPage }\n.onEach { /* our track loginc */ }\n.launchIn(scope)\n}\n}\n</code></pre>"},{"location":"state/","title":"State","text":"<p>The state is the bread and butter of Compose. This page describes the role of State in our architecture, different types of states and should and should not be a part of it</p> <p>This page will mostly rely on features and components familiar to android developers (like androidx.ViewModel) but the same principles can applied to any other components and tech stack powered by kotlin</p>"},{"location":"state/#viewmodel-state","title":"ViewModel State","text":"<p>In android, our ViewModel acts a mediator between the Business rules of our application and its presentation logic. The name of this component might change depending on your technical stack but not its responsibility. </p> <p>The State of a ViewModel is a representation of both our UI and business rules. In kotlin this State can be presented in many ways, by far the Most popular are <code>data class</code> and <code>sealed interface</code> or <code>sealed class</code>.</p> <p>It is recommended to have one State per ViewModel as it make</p>"},{"location":"state/#data-class","title":"Data class","text":"<p>The data class based is pretty straightforward and can be used in situations when you <code>Screen</code> has many things displayed at once.</p> <p>When combined with <code>StateFlow</code> we can easy and safely mutate it inside our ViewModel, while making sure only when state gets updated and changed, it will be consumed by our UI</p> <p>Lets take a look at this classic example of ViewModel state</p> <pre><code>data class ExampleState(\nval refreshing: Boolean = false,\nval items: List&lt;Item&gt; = emptyList(),\nval error: Error? = null\n)\n</code></pre> <p>In our <code>ViewModel</code> this state can be mutated by using <code>update</code> extension function</p> <pre><code>class ExampleViewModel(\nprivate val getItemsUseCase: GetItemsUseCase\n) : ViewModel() {\nprivate val _stateFlow = MutableStateFlow(ExampleState())\n// .asStateFlow() make our mutable flow immutable\n// making our ViewModel the only place where we can do\n// state updates\nval stateFlow = _stateFlow().asStateFlow()\ninit {\nviewModelScope.launch {\n_stateFlow.update { state -&gt; state.copy(refreshing = true)\n}\n// do some background work to load items\nval result: Result&lt;Items&gt; = getItemsUseCase()\n_stateFlow.update { state -&gt; state.copy(\nrefreshing = false,\nitems = result.getOrEmpty(),\nerror = result.exceptionOrNull()\n)\n}\n}\n}\n}\n</code></pre>"},{"location":"state/#sealed-interface-sealed-class","title":"Sealed Interface / Sealed Class","text":"<p>Describing your state using can <code>sealed interface</code> or <code>sealed class</code> provide some benefits comparing to <code>data class</code>. For one, it can much more clearly describe whats going one on the Screen as your state basically becomes a distinct set of possible outcomes, where one fuses into another, creating a small state machine</p> <pre><code>sealed interface PaymentState {\ndata class Summary(val price: Price): PaymentState\nobject Processing: PaymentState\nobject Completed: PaymentState\n}\n</code></pre> <p>The same thing can be achieved with data class, but this would require to introduce three booleans which introduces 2^3=8 possible states instead of desired three, making it much easier to make a mistake. </p> <p>And, of course these two can be combined, you can have <code>sealed interface</code> be a a part of bigger <code>data class</code> and different <code>data class</code> can represent <code>sealed interface</code> nodes.</p> <p>And our ViewModel can then look like this </p> <pre><code>class PaymentViewModel() {\ninit {\n_stateFlow.update { PaymentState.Summary(getPrice())) }\n}\nfun pay() {\nviewModelScope.launch {\n_stateFlow.update { PaymentState.Processing }\n// background stuff\n_stateFlow.update { PaymentState.Completed }\n}\n}\n}\n</code></pre>"},{"location":"state/#composable-state","title":"Composable State","text":"<p>Another type of state that can be exposed to our Screen is a State of other composable components. Pagers, Lazy Lists, state of the Bottom Sheets and scaffolds. </p>"}]}